<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>추첨/호명 관리</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="color-scheme" content="light" />
  <style>
    html, body { height: 100%; }
    /* 라이트 모드 강제 및 기본 텍스트 컬러 보장 */
    :root { color-scheme: light; }
    body { color: #111827; background-color: #f8fafc; }
    input, textarea, button, select { color: #111827; }
    table, th, td { color: #111827; }
    /* 스크롤 영역 테이블 고정 헤더 */
    thead th { position: sticky; top: 0; background: #f3f4f6; z-index: 1; }
  </style>
</head>
<body class="min-h-screen bg-gray-50 p-4 md:p-8">
  <div class="max-w-6xl mx-auto space-y-6">
    <header class="flex items-center justify-between">
      <h1 class="text-2xl md:text-3xl font-bold">🔢 추첨/호명 관리</h1>
      <div class="flex items-center gap-2">
        <button id="resetAll" class="px-3 py-2 rounded-xl bg-red-500 text-white shadow hover:opacity-90">전체 초기화</button>
      </div>
    </header>

    <!-- 입력 영역 -->
    <section class="grid md:grid-cols-2 gap-6">
      <div class="bg-white shadow rounded-2xl p-4 space-y-3">
        <h2 class="text-lg font-semibold">➕ 단일 추가</h2>
        <div class="grid grid-cols-5 gap-2 items-end">
          <div class="col-span-3">
            <label class="text-sm text-gray-600">대상자 이름</label>
            <input id="singleName" placeholder="예) 김철수" class="w-full px-3 py-2 rounded-xl border" />
          </div>
          <div class="col-span-2">
            <label class="text-sm text-gray-600">번호(숫자)</label>
            <input id="singleNumber" inputmode="numeric" placeholder="예) 12" class="w-full px-3 py-2 rounded-xl border" />
          </div>
          <div class="col-span-5 flex justify-end">
            <button id="addSingle" class="px-4 py-2 rounded-xl bg-blue-600 text-white shadow hover:opacity-90">추가</button>
          </div>
        </div>
      </div>

      <div class="bg-white shadow rounded-2xl p-4 space-y-3">
        <h2 class="text-lg font-semibold">📥 벌크 입력 (여러 명 한 번에)</h2>
        <div class="grid md:grid-cols-2 gap-3">
          <div>
            <label class="text-sm text-gray-600">대상자 (한 줄에 한 명)</label>
            <textarea id="bulkNames" placeholder="예)\n김철수\n이영희\n박민수, 101  ← 이렇게 '이름,번호'로 써도 자동 인식" class="w-full h-36 p-3 rounded-xl border resize-y"></textarea>
          </div>
          <div>
            <label class="text-sm text-gray-600">번호 목록 (줄/쉼표/세미콜론 가능)</label>
            <textarea id="bulkNumbers" placeholder="예)\n1,2,3,4\n또는\n1\n2\n3\n4" class="w-full h-36 p-3 rounded-xl border resize-y"></textarea>
          </div>
        </div>
        <div class="flex justify-end">
          <button id="pairing" class="px-4 py-2 rounded-xl bg-emerald-600 text-white shadow hover:opacity-90">페어링 생성</button>
        </div>
        <p class="text-xs text-gray-500">* 이름 줄에 <code>이름,번호</code> 또는 <code>이름 번호</code> 형태가 있으면 번호 칸이 비어도 자동 매칭합니다. 그 외는 왼쪽 이름순과 오른쪽 번호순으로 같은 순서로 짝지어집니다.</p>
      </div>
    </section>

    <!-- 검색/요약 -->
    <section class="flex flex-wrap items-center gap-3">
      <div class="flex-1 min-w-[220px]">
        <input id="query" placeholder="검색: 번호(정확히) 또는 이름 포함" class="w-full px-4 py-2 rounded-2xl border" />
      </div>
      <div id="summary" class="text-sm text-gray-600">총 0명 · 호명됨 0명</div>
    </section>

    <!-- 정렬 표시 -->
    <section class="bg-white shadow rounded-2xl overflow-hidden">
      <div class="px-4 py-3 border-b flex items-center justify-between">
        <h2 class="font-semibold">📋 현재 목록 (번호 오름차순)</h2>
        <span class="text-sm text-gray-500">체크하면 목록에서 제거됩니다.</span>
      </div>
      <div class="max-h-[55vh] overflow-auto">
        <table class="min-w-full">
          <thead class="bg-gray-100 text-left">
            <tr>
              <th class="p-3 w-16">호명</th>
              <th class="p-3 w-28">번호</th>
              <th class="p-3">이름</th>
            </tr>
          </thead>
          <tbody id="listBody"></tbody>
        </table>
      </div>
    </section>

    <!-- 호명됨 섹션 -->
    <section class="bg-white shadow rounded-2xl overflow-hidden">
      <div class="px-4 py-3 border-b flex items-center justify-between">
        <h2 class="font-semibold">✅ 호명됨 (체크로 제거된 항목)</h2>
        <span class="text-sm text-gray-500">클릭하면 복원됩니다.</span>
      </div>
      <div id="calledWrap" class="p-3 flex flex-wrap gap-2"></div>
    </section>

    <details class="bg-white shadow rounded-2xl p-4">
      <summary class="cursor-pointer font-semibold">도움말</summary>
      <ul class="list-disc pl-6 text-sm text-gray-700 space-y-1 mt-2">
        <li>벌크 입력에서는 왼쪽(이름)과 오른쪽(번호)을 같은 순서로 매칭합니다.</li>
        <li>이름 줄에 <code>이름,번호</code> 또는 <code>이름 번호</code> 형태가 있으면 번호 칸 없이도 자동 인식합니다.</li>
        <li>체크하면 해당 항목이 즉시 위 목록에서 제거되고, 아래 <b>호명됨</b> 영역으로 이동합니다. 배지를 클릭하면 다시 복원됩니다.</li>
        <li>데이터는 브라우저에 자동 저장됩니다(같은 컴퓨터/브라우저에서 유지).</li>
        <li>중복 번호가 있을 경우, 덮어쓰기 여부를 선택할 수 있습니다.</li>
      </ul>
    </details>
  </div>

  <script>
    (function(){
      const KEY = 'raffle_app_v1_html';
      /** @type {{name:string, number:number}[]} */
      let entries = [];
      /** @type {{name:string, number:number, ts:number}[]} */
      let called = [];

      // DOM
      const singleName = document.getElementById('singleName');
      const singleNumber = document.getElementById('singleNumber');
      const addSingle = document.getElementById('addSingle');
      const bulkNames = document.getElementById('bulkNames');
      const bulkNumbers = document.getElementById('bulkNumbers');
      const pairing = document.getElementById('pairing');
      const listBody = document.getElementById('listBody');
      const calledWrap = document.getElementById('calledWrap');
      const resetAll = document.getElementById('resetAll');
      const query = document.getElementById('query');
      const summary = document.getElementById('summary');

      // Load
      try {
        const raw = localStorage.getItem(KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          entries = parsed.entries || [];
          called = parsed.called || [];
        }
      } catch (e) { console.error(e); }

      function save(){
        localStorage.setItem(KEY, JSON.stringify({ entries, called }));
      }

      function parseList(text){
        if (!text || !text.trim()) return [];
        return text.split(/\n|,|\t|;/g).map(s=>s.trim()).filter(Boolean);
      }

      function render(){
        summary.textContent = `총 ${entries.length}명 · 호명됨 ${called.length}명`;
        const q = (query.value || '').trim();
        let list = [...entries].sort((a,b)=>a.number-b.number);
        if (q) {
          if (/^\d+$/.test(q)) {
            const n = Number(q);
            list = list.filter(e=>e.number===n);
          } else {
            list = list.filter(e=>e.name.includes(q));
          }
        }
        listBody.innerHTML = '';
        if (list.length===0){
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 3;
          td.className = 'p-6 text-center text-gray-400';
          td.textContent = '항목이 없습니다.';
          tr.appendChild(td);
          listBody.appendChild(tr);
        } else {
          for (const e of list){
            const tr = document.createElement('tr');
            tr.className = 'border-t hover:bg-gray-50';

            const tdCheck = document.createElement('td');
            tdCheck.className = 'p-3 align-middle';
            const cb = document.createElement('input');
            cb.type='checkbox';
            cb.title='호명 처리';
            cb.addEventListener('change',()=> handleCall(e.number));
            tdCheck.appendChild(cb);

            const tdNum = document.createElement('td');
            tdNum.className = 'p-3 font-mono';
            tdNum.textContent = `#${e.number}`;

            const tdName = document.createElement('td');
            tdName.className = 'p-3';
            tdName.textContent = e.name;

            tr.appendChild(tdCheck); tr.appendChild(tdNum); tr.appendChild(tdName);
            listBody.appendChild(tr);
          }
        }

        // called chips
        calledWrap.innerHTML = '';
        if (called.length===0){
          const span = document.createElement('span');
          span.className = 'text-gray-400';
          span.textContent = '아직 없습니다.';
          calledWrap.appendChild(span);
        } else {
          for (const c of called){
            const btn = document.createElement('button');
            btn.className = 'px-3 py-1 rounded-full border shadow-sm hover:bg-gray-50';
            btn.title = '클릭하여 복원';
            btn.textContent = `#${c.number} · ${c.name}`;
            btn.addEventListener('click',()=>restoreCalled(c.number));
            calledWrap.appendChild(btn);
          }
        }
      }

      function mergeUnique(base, adds){
        const map = new Map(base.map(e=>[e.number, e]));
        const dups = [];
        for (const a of adds){ if (map.has(a.number)) dups.push(a); }
        if (dups.length){
          const overwrite = confirm(
            `중복 번호가 ${dups.length}개 있습니다. 같은 번호는 덮어쓸까요?\n`+
            dups.map(d=>`#${d.number} ← ${d.name}`).join('\n')
          );
          if (!overwrite){
            for (const a of adds){ if (!map.has(a.number)) map.set(a.number, a); }
            return Array.from(map.values());
          }
        }
        for (const a of adds){ map.set(a.number, a); }
        return Array.from(map.values());
      }

      function handlePairing(){
        const nameLines = (bulkNames.value||'')
          .split(/\n/g).map(s=>s.trim()).filter(Boolean);
        let numbers = parseList(bulkNumbers.value).map(n=>Number(n));

        const autoPairs = [];
        const remainNames = [];
        for (const line of nameLines){
          const m = line.match(/^(.*?)[,\s]+(-?\d+)$/);
          if (m){ autoPairs.push({name:m[1].trim(), number:Number(m[2])}); }
          else { remainNames.push(line); }
        }
        const pairs = [...autoPairs];
        for (let i=0;i<remainNames.length;i++){
          const nm = remainNames[i];
          const num = numbers[i];
          if (nm && (num===0 || !!num)) pairs.push({name:nm, number:Number(num)});
        }
        const invalid = pairs.filter(p=>!p.name || Number.isNaN(p.number));
        if (invalid.length){
          alert('이름 또는 번호가 비어 있거나 숫자가 아닙니다.\n문제 항목 예: '+ invalid[0].name + ' / ' + invalid[0].number);
          return;
        }
        entries = mergeUnique(entries, pairs);
        bulkNames.value = '';
        bulkNumbers.value = '';
        save();
        render();
      }

      function handleAddSingle(){
        const nm = (singleName.value||'').trim();
        const numStr = (singleNumber.value||'').replace(/[^-\d]/g,'');
        const num = Number(numStr);
        if (!nm || Number.isNaN(num)){
          alert('이름과 숫자 번호를 정확히 입력하세요.');
          return;
        }
        entries = mergeUnique(entries, [{ name: nm, number: num }]);
        singleName.value = '';
        singleNumber.value = '';
        save();
        render();
      }

      function handleCall(num){
        const idx = entries.findIndex(e=>e.number===num);
        if (idx===-1) return;
        const target = entries[idx];
        entries.splice(idx,1);
        called.unshift({ ...target, ts: Date.now() });
        save();
        render();
      }

      function restoreCalled(num){
        const idx = called.findIndex(e=>e.number===num);
        if (idx===-1) return;
        const target = called[idx];
        called.splice(idx,1);
        entries = mergeUnique(entries, [{ name: target.name, number: target.number }]);
        save();
        render();
      }

      function doReset(){
        if (!confirm('전체 초기화할까요? (호명됨 포함)')) return;
        entries = [];
        called = [];
        localStorage.removeItem(KEY);
        render();
      }

      // events
      pairing.addEventListener('click', handlePairing);
      addSingle.addEventListener('click', handleAddSingle);
      resetAll.addEventListener('click', doReset);
      query.addEventListener('input', render);

      // 초기 렌더
      render();
    })();
  </script>
</body>
</html>
